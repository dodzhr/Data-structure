#include<iostream>
using namespace std;
struct node
{
	int val;
	node* left;
	node* right;
	int height;
};

class avl
{
private:
	node* root;
public:
	avl();
	~avl();

	node* get_root();
	int height(node* r);
	node* rotate_right(node* r);
	node* rotate_left(node* r);
	node* insert(node* r,int num);
	node* value_insertion(node* r, int num);
	int get_balance(node* r);
	void print(node* r);


};



avl::avl()
{
	root = NULL;
}

avl::~avl()
{

}

node *avl::get_root()
{
	return root;
}



int avl::height(node* rt)
{
	if (rt == NULL)
	{
		return 0;
	}

	return rt->height;
}


int avl::get_balance(node* rt)
{
	if (rt == NULL)
	{
		return 0;
	}

	return height(rt->left) - height(rt->right);
}



node* avl::rotate_right(node* rt)
{
	node* y = rt->left;
	node* x = y->right;

	y->right = rt;
	rt->left = x;

	rt->height = max(height(rt->left), height(rt->right)) + 1;
	y->height = max(height(y->left), height(y->right)) + 1;
	return y;
}

node* avl::rotate_left(node* rt)
{
	node* y = rt->right;
	node* x = rt->left;

	rt->left = y;
	y->right = x;

	rt->height = 1 + max(height(rt->left), height(rt->right));
	y->height = 1 + max(height(y->left), height(y->right));

	return y;
}

node* avl::insert(node* rt,int num)
{
	rt = new node;
	rt->left = NULL;
	rt->right = NULL;
	rt->val= num;
	return rt;
}

node* avl::value_insertion(node* rt, int num)
{
	if (get_root() == NULL)
	{
		root = insert(rt, num);
		
		return root;
	}
	else if (rt == NULL)
	{
		rt = insert(rt, num);
		return rt;
	}
	else if (num < rt->val)
	{
		rt->left = value_insertion(rt->left, num);
	}
	else if (num > rt->val)
	{
		rt->right = value_insertion(rt->right,num);
	}
	else
	{
		return rt;
	}

	rt->height = 1 + max(height(rt->left), height(rt->right));
	
	int balance = get_balance(rt);

	if (balance > 1 && num < rt->left->val)
	{
		return rotate_right(rt);
	}
	else if (balance <-1 && num >rt->right->val)
	{
		return rotate_left(rt);
	}
	else if (balance > 1 && num < rt->left->val)
	{
		root->left = rotate_left(rt);
		return rotate_right(rt);
	}
	else if (balance<-1 && num>rt->right->val)
	{
		rt->right = rotate_right(rt);
		return rotate_left(rt);
	}

	return rt;
}

void avl::print(node* root)
{
	if (root == NULL)
	{
		cout << "Empty Tree" << endl;
	}
	else if (root->left != NULL)
	{
		print(root->left);
	}
	cout << root->val << " ";
	if (root->right != NULL)
	{
		print(root->right);
	}

	return;
}


int main()
{
	avl list;
	list.value_insertion(list.get_root(), 6);
	list.value_insertion(list.get_root(), 2);
	list.value_insertion(list.get_root(), 10);
	list.value_insertion(list.get_root(), 5);

	list.print(list.get_root());

	return 0;
}
